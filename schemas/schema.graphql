#The root API types

"""
All queries
"""
type Query {
    """
    Requests an object (node) using the given ID. If the given ID is invalid an error will be returned
    """
    node (
        """
        The ID of the node to return. This can't be empty or null
        """
        id: ID!
    ): Node

    """
    Requests issues in this instance of ccims
    """
    issues(
        """
        Returns all issues in the system that match the other inputs after the given one (inclusive)
        """
        after: ID, 
        """
        Returns all issues in the system that match the other inputs before the given one (exclusive)
        """
        before: ID,
        """
        Filters the issues to return by the specified criteria. A returned issue will match all of the given parameters
        """
        filterBy: IssueFilter, 
        """
        If given, the first _n_ issues found in the system (matching the other given parameters) will be returned. 
        If this is given, `last` can't be given or an error will be returned
        """
        first: Int, 
        """
        If given, the last _n_ issues found in the system (matching the other given parameters) will be returned.
        If this is given, `first` can't be given or an error will be returned
        """
        last: Int): IssuePage

}

type Mutation {
    createIssue(input: CreateIssueInput): CreateIssuePayload
    addIssueComment(input: AddIssueCommentInput): AddIssueCommentPayload
}

#----------Basic types---------------
"""
An object which can be identified by an ID - called a node
"""
interface Node {
    """
    The ID of this node. Every node will have an non-empty and non-null edge.

    If this is ever empty or null, something went wrong.
    """
    id: ID!
}

"""
A page (sometimes also called connection) of multiple elements. 

A page has a content (the list of elements) of some type (depending on the type of page).
It also has information about the page as well as a count of total elements of that type (not only the ones on this page)
"""
interface Page {
    pageInfo: PageInfo!
    totalCount: Int!
}

type PageInfo {
    startCursor: String
    endCursor: String
    endID: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}


#User
type User implements Node {
    id: ID!
}

type UserPage implements Page {
    nodes: [User]
    edges: [UserEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type UserEdge {
    node: User
    cursor: String!
}

input UserFilter {
    username: String
}


#Component
type Component implements Node {
    id: ID!
}

type ComponentPage implements Page {
    nodes: [Component]
    edges: [ComponentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ComponentEdge {
    node: Component
    cursor: String
}

input ComponentFilter {
    name: String
}

type ComponentInterface {
    name: String!
}


#Issue
type Issue implements Comment {
    id: ID!
    title: String!
    components(after: ID, before: ID, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    body: String
    bodyRendered: String
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    updatedAt: Date
    isOpen: Boolean!
    isDuplicate: Boolean!
    category: IssueCategory!
    linkedIssues(after: ID, before: ID, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    assignees(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    labels(after: ID, before: ID, filterBy: LabelFilter, first: Int, last: Int): LabelPage
    participants(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    timeline(after: ID, before: ID, filterBy: IssueTimelineItemFilter, first: Int, last: Int): IssueTimelineItemPage
    locations(after: ID, before: ID, filterBy: IssueLocationFilter, first: Int, last: Int): IssueLocationPage
    currentUserCanEdit: Boolean!
    currentUserCanComment: Boolean!
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    spentTime: TimeSpan
}

input CreateIssueInput {
    title: String!,
    body: String,
    componentIDs: [ID!]!,
    category: IssueCategory,
    labels: [ID!],
    assignees: [ID!],
    locations: [ID!],
    startDate: Date,
    dueDate: Date,
    estimatedTime: TimeSpan,
    clientMutationID: String
}

type CreateIssuePayload {
    clientMutationID: String,
    issue: Issue
}

type IssuePage implements Page {
    nodes: [Issue]
    edges: [IssueEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueEdge {
    node: Issue
    cursor: String
}

input IssueFilter {
    title: String
}


#Issue timeline items

interface IssueTimelineItem {
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type IssueTimelineItemPage implements Page {
    nodes: [IssueTimelineItem]
    edges: [IssueTimelineItemEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueTimelineItemEdge {
    node: IssueTimelineItem
    cursor: String
}

input IssueTimelineItemFilter {
    createdBy: ID
}

#IssueComment
interface Comment {
    id: ID!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

type IssueComment implements IssueTimelineItem & Comment & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

input AddIssueCommentInput {
    body: String!
    clientMutationID: String
    issueID: ID!
}

type AddIssueCommentPayload {
    comment: IssueComment
    clientMutationID: String
    commentEdge: IssuecommentEdge
    timelineEdge: IssueTimelineItemEdge
}

type IssueCommentPage implements Page {
    nodes: [IssueComment]
    edges: [IssueCommentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueCommentEdge {
    node: IssueComment
    cursor: String
}

input IssueCommentFilter {
    createdBy: ID
}

type DeletedIssueComment implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    deletedBy: User
    deletedAt: Date
}

input DeleteIssueCommentInput {
    clientMutationID: String
    issueComment: ID
}

type DeleteIssueCommentPayload {
    clientMutationID: String
    deletedComment: DeletedIssueComment
    timelineEdge: IssueTimelineItemEdge
}

#when mentioned in a commit or a pull request
type ReferencedByOtherEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    component: Component
    source: String
    sourceURL: String
}

type ReferencedByIssueEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    mentionedAt: Issue
    mentionedInComment: IssueComment
}

#when an user actively links another issue
type LinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedIssue: Issue
}

input LinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToLink: ID!
}

type LinkIssuePayload {
    clientMutationID: String
    linkedIssue: Issue
    linkedIssueEdge: IssueEdge
    timelineEdge: IssueTimelineItemEdge
}

# when an user unlinks another issue
type UnlinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLinkedIssue: Issue
}

input UnlinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToUnlink: ID!
}

type UnlinkIssuePayload {
    clientMutationID: String
    unlinkedIssue: Issue
    timelineEdge: IssueTimelineItemEdge
}

#when another issue links this issue
type WasLinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedBy: Issue
}

#when another issue unlinks this issue
type WasUnlinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    unlinkedBy: Issue
}

type LabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    label: Label!
}

input AddLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type AddLabelPayload {
    clientMutationID: String
    label: Label
    labelEdge: LabelEdge
    timelineEdge: IssueTimelineItemEdge
}

type UnlabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLabel: Label!
}

input RemoveLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type RemoveLabelPayload {
    clientMutationID: String
    label: Label
    timelineEdge: IssueTimelineItemEdge
}

type PinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input PinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type PinIssuePayload {
    clientMutationID:
    pinnedIssue: Issue
    component: Component
    timelineEdge: IssueTimeline
}

type UnpinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input UnpinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type UnpinIssuePayload {
    clientMutationID:
    unpinnedIssue: Issue
    component: Component
    timelineEdge: IssueTimeline
}

type RenamedTitleEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldTitle: String!
    newTitle: String!
}

input RenameTitleInput {
    clientMutationID: String
    issue: ID!
    newTitle: String!
}

type RenameTitlePayload {
    clientMutationID: String
    issue: Issue
    timelineEdge: IssueTimelineItemEdge
}

type CategoryChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldType: IssueCategory!
    newType: IssueCategory!
}

type AssignedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    assignee: User!
}

type UnassignedEvet implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedAssignee: User!
}

type ClosedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type ReopenedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type PriorityChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldPriority: Priority
    newPriority: Priority
}

type StartDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldStartDate: Date
    newStartDate: Date
}

type DueDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldDueDate: Date
    newDueDate: Date
}

type EstimatedTimeChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldEstimatedTime: TimeSpan
    newEstimatedTime: TimeSpan
}

type AddedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    location: IssueLocation!
}

type RemovedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLocation: IssueLocation!
}

type MarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    originalIssue: Issue
}

type UnmarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}



type ReactionGroup {
    users: [User]
    reaction: String!
}

type ReactionGroupPage {
    nodes: [ReactionGroup]
    edges: [ReactionGroupEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ReactionGroupEdge {
    node: ReactionGroup
    cursor: String
}

input ReactionGroupFilter {
    reaction: String
}

type Label implements Node {
    id: ID!
    name: String!
    description: String
    colour: Colour
}

type LabelPage {
    nodes: [Label]
    edges: [LabelEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    node: Label
    cursor: String
}

input LabelFilter {
    name: String
}

#-------------------------------------Scalars and enums------------------------------------
enum Priority {
    LOW,
    MEDIUM,
    HIGH
}

enum IssueCategory {
    BUG,
    FEATURE_REQUEST,
    UNCLASSIFIED
}

"""
The type of a timeline item/event so it can be filtered for <sup>(because GraphQL doesn't allow to filter for a type)</sup>
"""
enum IssueTimelineItemType {
    """
    A still visible comment on an issue (not including the actual issue text)
    """
    ISSUE_COMMENT,

    """
    A comment that has been deleted by a user. This will contain no text etc., but a message should be shown in place of the comment stating that this is a deleted comment
    """
    DELETED_ISSUE_COMMENT,

    """
    An event when this issue was referenced by an element in an IMS that is not an issue (e.g. in a commit message, pull request etc.)
    """
    REFERENCED_BY_OTHER_EVENT,

    """
    An event when this issue was referenced by an other issue in an IMS or the ccims itself
    """
    REFERENCED_BY_ISSUE_EVENT,

    """
    A link from this issue to another issue was created
    """
    LINK_EVENT,

    """
    A link from this issue to another issue was removed
    """
    UNLINK_EVENT,

    """
    An event if this issue was linked to in another issue
    """
    WAS_LINKED_EVENT,

    """
    An event if the link from another issue to this one was removed
    """
    WAS_UNLINKED_EVENT,


    """
    A label was added to this issue
    """
    LABELLED_EVENT,

    """
    A label was removed from tis issue
    """
    UNLABELLED_EVENT,

    """
    This issue was pinned as important issue in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    PINNED_EVENT,

    """
    This issue was unpinned in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    UNPINNED_EVENT,

    """
    Occurs if the title of the issue has been changed
    """
    RENAMED_TITLE_EVENT,

    """
    An event if the category (see `enum IssueCategory`) of the issue has been changed
    """
    CATEGORY_CHANGED_EVENT,

    """
    If a user has been assigned as responsible person for this issue
    """
    ASSIGNED_EVENT,

    """
    If a user has been unassigned from this issue and is no longer responsible
    """
    UNASSIGNED_EVENT,

    """
    Happens if the issue has been closed by anybody
    """
    CLOSED_EVENT,

    """
    Happens if the issue has been reopened after being closed by anybody.

    _This event doesn't occur on the first opening of the issue_
    """
    REOPENED_EVENT,

    """
    If the issue priority was changed (see `enum Priority`)
    """
    PRIORITY_CHANGED_EVENT,

    """
    An event if the date the issue gets relevant/starts has changed
    """
    START_DATE_CHANGED_EVENT,

    """
    An event if the date the issue is due on/must be finished by was changed
    """
    DUE_DATE_CHANGED_EVENT,

    """
    The estimated time required to resolve this issue was updated
    """
    ESTIMATED_TIME_CHANGED_EVENT,

    """
    Event if the cross component issue was added to another location (another component/another)
    """
    ADDED_LOCATION_EVENT,

    """
    Event if the cross component issue was removed from a location (another component/another)
    """
    REMOVED_LOCATION_EVENT,

    """
    Occurs if this issue was marked as duplicate of some other issue which is known to the ccims.
    
    (if the issue in unknown to the ccims at time of marking it as a duplicate; it's not guaranteed, that the mark will be synced)
    """
    MARKED_AS_DUPLICATE_EVENT,

    """
    An event if the issue is no longer a duplicate of another issue
    """
    UNMARKED_AS_DUPLICATE_EVENT,
}

"""
The `Date` scalar is a sting containing a date in a format compatible with _ISO-8601_

Example: `"2011-10-10T14:48:00"`
"""
scalar Date

"""
A integer number representing the length of the time span in milliseconds

Example: `60000` (equivalent to a time span of one minute)
"""
scalar TimeSpan

"""
A scalar type representing a colour in RGB colour space.
The scalar must be a string in CSS Colour Hex format: 
`#rrggbb` where `rr`, `gg`, `bb` are the hex values between _0_ and _ff_

Example: `#ffff00` (would be a _beautiful_ yellow)
"""
scalar Colour

#--------------------------------Union types-------------------------------------------------
union IssueLocation = Component | ComponentInterface

type IssueLocationPage {
    nodes: [IssueLocation]
    edges: [IssueLocationEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueLocationEdge {
    node: IssueLocation
    cursor: String
}

input IssueLocationFilter {
    name: String
}