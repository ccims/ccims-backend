#The root api types

"""
All queries
"""
type Query {
    """
    Requets an object (node) using the given ID. If the given ID is invalid an error will be returned
    """
    node (
        """
        The ID of the node to return. This can't be empty or null
        """
        id: ID!
    ): Node

    """
    Requests issues in this instace of ccims
    """
    issues(
        """
        Returns all issues in the system that match the other inputs after the given one (inclusive)
        """
        after: ID, 
        """
        Returns all issues in the system that match the other inputs before the given one (exclusive)
        """
        before: ID,
        """
        Filters the issues to return by the specified criteria. A returned issue will match all of the given parameters
        """
        filterBy: IssueFilter, 
        """
        If given, the first _n_ issues found in the system (matching the other given parameters) will be returned. 
        If this is given, `last` can't be given or an error will be returned
        """
        first: Int, 
        """
        If given, the last _n_ issues found in the system (matching the other given parameters) will be returned.
        If this is given, `first` can't be given or an error will be returned
        """
        last: Int): IssuePage

}

type Mutation {

}

#----------Basic types---------------
"""
An object which can be identified by an ID - called a node
"""
interface Node {
    """
    The ID of this node. Evey node will have an non-empty and non-null edge.

    If this is ever empty or null, something went wrong.
    """
    id: ID!
}

"""
A page (sometimes also called connection) of multiple elements. 

A page has a content (the list of elements) of some type (depending on the type of page).
It also has information about the page as well as a count of total elements of that type (not only the ones on this page)
"""
interface Page {
    pageInfo: PageInfo!
    totalCount: Int!
}

type PageInfo {
    startCursor: String
    endCursor: String
    endID: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}


#User
type User implements Node {
    id: ID!
}

type UserPage implements Page {
    nodes: [User]
    edges: [UserEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type UserEdge {
    node: User
    cursor: String!
}

input UserFilter {
    username: String
}


#Component
type Component implements Node {
    id: ID!
}

type ComponentPage implements Page {
    nodes: [Component]
    edges: [ComponentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ComponentEdge {
    node: Component
    cursor: String
}

input ComponentFilter {
    name: String
}

type ComponentInterface {
    name: String!
}


#Issue
type Issue implements Comment {
    id: ID!
    title: String!
    components(after: ID, before: ID, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    body: String
    bodyRendered: String
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    updatedAt: Date
    isOpen: Boolean!
    isDuplicate: Boolean!
    category: IssueCategory!
    linkedIssues(after: ID, before: ID, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    assignees(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    labels(after: ID, before: ID, filterBy: LabelFilter, first: Int, last: Int): LabelPage
    participants(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    timeline(after: ID, before: ID, filterBy: IssueTimelineItemFilter, first: Int, last: Int): IssueTimelineItemPage
    locations(after: ID, before: ID, filterBy: IssueLocationFilter, first: Int, last: Int): IssueLocationPage
    currentUserCanEdit: Boolean!
    currentUserCanComment: Boolean!
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    spentTime: TimeSpan
}

input CreateIssueInput {
    title: String!,
    body: String,
    componentIDs: [ID!]!,
    category: IssueCategory,
    labels: [ID!],
    assignees: [User!],
    locations: [ID!],
    startDate: Date,
    dueDate: Date,
    estimatedTime: TimeSpan,
    clientMutationID: String
}

type CreateIssuePayload {
    clientMutationID: String,
    issue: Issue
}

type IssuePage implements Page {
    nodes: [Issue]
    edges: [IssueEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueEdge {
    node: Issue
    cursor: String
}

input IssueFilter {
    title: String
}


#Issue timeline items

interface IssueTimelineItem {
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type IssueTimelineItemPage implements Page {
    nodes: [IssueTimelineItem]
    edges: [IssueTimelineItemEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueTimelineItemEdge {
    node: IssueTimelineItem
    cursor: String
}

input IssueTimelineItemFilter {
    createdBy: ID
}

#IssueComment
interface Comment {
    id: ID!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

type IssueComment implements IssueTimelineItem & Comment & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

input AddIssueCommentInput {
    body: String!
    clientMutationID: String
    issueID: ID!
}

type AddIssueCommentPayload {
    comment: IssueComment
    clientMutationID: String
    commentEdge: IssuecommentEdge
    timelineEdge: IssueTimelineItemEdge
}

type IssueCommentPage implements Page {
    nodes: [IssueComment]
    edges: [IssuecommentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueCommentEdge {
    node: IssueComment
    cursor: String
}

input IssueCommentFilter {
    createdBy: ID
}

type DeletedIssueComment implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    deletedBy: User
    deletedAt: Date
}

#when mentioned in a commit or a pull request
type ReferencedByOtherEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    component: Component
    source: String
    sourceURL: String
}

type ReferencedByIssueEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    mentionedAt: Issue
    mentionedInComment: IssueComment
}

#when an user actively links another issue
type LinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedIssue: Issue
}

# when an user unlinks another issue
type UnlinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLinkedIssue: Issue
}

#when another issue links this issue
type WasLinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedBy: Issue
}

#when another issue unlinks this issue
type WasUnlinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    unlinkedBy: Issue
}

type LabeledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    label: Label!
}

type UnlabledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLabel: Label!
}

type PinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type UnpinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type RenamedTitleEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldTitle: String!
    newTitle: String!
}

type CategoryChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldType: IssueCategory!
    newType: IssueCategory!
}

type AssignedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    assignee: User!
}

type UnassignedEvet implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedAssignee: User!
}

type ClosedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type ReopenedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type PriorityChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldPriority: Priority
    newPriority: Priority
}

type StartDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldStartDate: Date
    newStartDate: Date
}

type DueDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldDueDate: Date
    newDueDate: Date
}

type EstimatedTimeChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldEstimatedTime: TimeSpan
    newEstimatedTime: TimeSpan
}

type AddedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    location: IssueLocation!
}

type RemovedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLocation: IssueLocation!
}

type MarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    originalIssue: Issue
}

type UnmarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}



type ReactionGroup {
    users: [User]
    reaction: String!
}

type ReactionGroupPage {
    nodes: [ReactionGroup]
    edges: [ReactionGroupEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ReactionGroupEdge {
    node: ReactionGroup
    cursor: String
}

input ReactionGroupFilter {
    reaction: String
}

type Label implements Node {
    id: ID!
    name: String!
    description: String
    color: Color
}

type LabelPage {
    nodes: [Label]
    edges: [LabelEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    node: Label
    cursor: String
}

input LabelFilter {
    name: String
}

#scalars
enum Priority {
    LOW,
    MEDIUM,
    HIGH
}

enum IssueCategory {
    BUG,
    FEATURE_REQUEST,
    UNCLASSIFIED
}

enum IssueTimelineItemType {
    ISSUE_COMMENT,
    DELETED_ISSUE_COMMENT,
    REFERENCED_BY_OTHER_EVENT,
    REFERENCED_BY_ISSUE_EVENT,
    LINK_EVENT,
    UNLINK_EVENT,
    WAS_LINKED_EVENT,
    WAS_UNLINKED_EVENT,
    LABELED_EVENT,
    UNLABELED_EVENT,
    PINNED_EVENT,
    UNPINNED_EVENT,
    RENAMED_TITLE_EVENT,
    CATEGORY_CHANGED_EVENT,
    ASSIGNED_EVENT,
    UNASSIGNED_EVENT,
    CLOSED_EVENT,
    REOPENED_EVENT,
    PRIORITY_CHANGED_EVENT,
    START_DATE_CHANGED_EVENT,
    DUE_DATE_CHANGED_EVENT,
    ESTIMATED_TIME_CHANGED_EVENT,
    ADDED_LOCATION_EVENT,
    REMOVED_LOCATION_EVENT,
    MARKED_AS_DUPLICATE_EVENT,
    UNMARKED_AS_DUPLICATE_EVENT,
}

scalar Date

scalar TimeSpan

scalar Color

#unions
union IssueLocation = Component | ComponentInterface

type IssueLocationPage {
    nodes: [IssueLocation]
    edges: [IssueLocationEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueLocationEdge {
    node: IssueLocation
    cursor: String
}

input IssueLocationFilter {
    name: String
}