#The root API types

"""
All queries
"""
type Query {
    """
    Requests an object (node) using the given ID. If the given ID is invalid an error will be returned
    """
    node (
        """
        The ID of the node to return. This can't be empty or null
        """
        id: ID!
    ): Node

    """
    Requests issues in this instance of ccims
    """
    issues(
        """
        Returns all issues in the system that match the other inputs after the given one (inclusive)
        """
        after: ID, 
        """
        Returns all issues in the system that match the other inputs before the given one (exclusive)
        """
        before: ID,
        """
        Filters the issues to return by the specified criteria. A returned issue will match all of the given parameters
        """
        filterBy: IssueFilter, 
        """
        If given, the first _n_ issues found in the system (matching the other given parameters) will be returned. 
        If this is given, `last` can't be given or an error will be returned
        """
        first: Int, 
        """
        If given, the last _n_ issues found in the system (matching the other given parameters) will be returned.
        If this is given, `first` can't be given or an error will be returned
        """
        last: Int
    ): IssuePage

}

type Mutation {
    createIssue(input: CreateIssueInput): CreateIssuePayload
    addIssueComment(input: AddIssueCommentInput): AddIssueCommentPayload
}

#----------Basic types---------------
"""
An object which can be identified by an ID - called a node
"""
interface Node {
    """
    The ID of this node. Every node will have an non-empty and non-null edge.

    If this is ever empty or null, something went wrong.
    """
    id: ID!
}

"""
A page (sometimes also called connection) of multiple elements. 

A page has a content (the list of elements) of some type (depending on the type of page).
It also has information about the page as well as a count of total elements of that type (not only the ones on this page)
"""
interface Page {
    pageInfo: PageInfo!
    totalCount: Int!
}

type PageInfo {
    startCursor: String
    endCursor: String
    endID: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}


#User
type User implements Node {
    id: ID!
}

type UserPage implements Page {
    nodes: [User]
    edges: [UserEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type UserEdge {
    node: User
    cursor: String!
}

input UserFilter {
    username: String
}


#Component
type Component implements Node {
    id: ID!
}

type ComponentPage implements Page {
    nodes: [Component]
    edges: [ComponentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ComponentEdge {
    node: Component
    cursor: String
}

input ComponentFilter {
    name: String
}

type ComponentInterface {
    name: String!
}


#Issue
type Issue implements Comment {
    id: ID!
    title: String!
    components(after: ID, before: ID, filterBy: ComponentFilter, first: Int, last: Int): ComponentPage
    body: String
    bodyRendered: String
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    updatedAt: Date
    isOpen: Boolean!
    isDuplicate: Boolean!
    category: IssueCategory!
    linkedIssues(after: ID, before: ID, filterBy: IssueFilter, first: Int, last: Int): IssuePage
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    assignees(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    labels(after: ID, before: ID, filterBy: LabelFilter, first: Int, last: Int): LabelPage
    participants(after: ID, before: ID, filterBy: UserFilter, first: Int, last: Int): UserPage
    timeline(after: ID, before: ID, filterBy: IssueTimelineItemFilter, first: Int, last: Int): IssueTimelineItemPage
    locations(after: ID, before: ID, filterBy: IssueLocationFilter, first: Int, last: Int): IssueLocationPage
    currentUserCanEdit: Boolean!
    currentUserCanComment: Boolean!
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    spentTime: TimeSpan
}

input CreateIssueInput {
    title: String!
    body: String
    componentIDs: [ID!]!
    category: IssueCategory
    labels: [ID!]
    assignees: [ID!]
    locations: [ID!]
    startDate: Date
    dueDate: Date
    estimatedTime: TimeSpan
    clientMutationID: String
}

type CreateIssuePayload {
    clientMutationID: String
    issue: Issue
}

type IssuePage implements Page {
    nodes: [Issue]
    edges: [IssueEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueEdge {
    node: Issue
    cursor: String
}

input IssueFilter {
    title: String
}


#Issue timeline items

interface IssueTimelineItem {
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type IssueTimelineItemPage implements Page {
    nodes: [IssueTimelineItem]
    edges: [IssueTimelineItemEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueTimelineItemEdge {
    node: IssueTimelineItem
    cursor: String
}

"""
Filters for certain timeline events.

__Please note:__ It's currently __not__ possible to filter for specific properties of an event. Might be added in future
"""
input IssueTimelineItemFilter {
    """
    Filters for the creator user of the timeline event. The id of the user must match any of the given ids
    """
    createdBy: [ID!]
    """
    The timeline event must have occurred __after__ the given date to match the filter
    """
    createdAfter: Date
    """
    The timeline event must have occurred __before__ the given date to match the filter
    """
    createdBefore: Date
}

#IssueComment
interface Comment {
    id: ID!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

type IssueComment implements IssueTimelineItem & Comment & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    editedBy: User
    createdAt: Date!
    editedAt: Date
    body: String
    bodyRendered: String
    reactions(after: ID, before: ID, filterBy: ReactionGroupFilter, first: Int, last: Int): ReactionGroupPage
    currentUserCanEdit: Boolean!
}

input AddIssueCommentInput {
    body: String!
    clientMutationID: String
    issueID: ID!
}

type AddIssueCommentPayload {
    comment: IssueComment
    clientMutationID: String
    commentEdge: IssueCommentEdge
    timelineEdge: IssueTimelineItemEdge
}

type IssueCommentPage implements Page {
    nodes: [IssueComment]
    edges: [IssueCommentEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueCommentEdge {
    node: IssueComment
    cursor: String
}

"""
Filter for comments on issues (not including the issue bodies themselves)
"""
input IssueCommentFilter {
    """
    The id of the issue the comment belongs to must match any of the given ids
    """
    issue: [ID!]
    """
    The id of the user creating the comment. Must match any one of the given ids
    """
    createdBy: [ID!]
    """
    The id of the user who __last__ edited the comment must match any of the given ids
    """
    editedBy: [ID!]
    """
    Match all comments created after the given date (inclusive)
    """
    createdAfter: Date
    """
    Match all comments created before the given date (inclusive)
    """
    createdBefore: Date
    """
    Match all comments last edited after the given date (inclusive)
    """
    editedAfter: Date
    """
    Match all comments last edited before the given date (inclusive)
    """
    editedBefore: Date
    """
    The body of a comment must match this __RegEx__ to match the filter
    """
    body: String
    """
    A comment must have all the reactions in one of the lists given.
    """
    reactions: [[String!]!]
    """
    If given, filters for comments which the user either has or hasn't got edit permissions
    """
    currentUserCanEdit: Boolean
}

type DeletedIssueComment implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    deletedBy: User
    deletedAt: Date
}

input DeleteIssueCommentInput {
    clientMutationID: String
    issueComment: ID
}

type DeleteIssueCommentPayload {
    clientMutationID: String
    deletedComment: DeletedIssueComment
    timelineEdge: IssueTimelineItemEdge
}

#when mentioned in a commit or a pull request
type ReferencedByOtherEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    component: Component
    source: String
    sourceURL: String
}

type ReferencedByIssueEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    mentionedAt: Issue
    mentionedInComment: IssueComment
}

#when an user actively links another issue
type LinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedIssue: Issue
}

input LinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToLink: ID!
}

type LinkIssuePayload {
    clientMutationID: String
    linkedIssue: Issue
    linkedIssueEdge: IssueEdge
    timelineEdge: IssueTimelineItemEdge
}

# when an user unlinks another issue
type UnlinkEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLinkedIssue: Issue
}

input UnlinkIssueInput {
    clientMutationID: String,
    issue: ID!
    issueToUnlink: ID!
}

type UnlinkIssuePayload {
    clientMutationID: String
    unlinkedIssue: Issue
    timelineEdge: IssueTimelineItemEdge
}

#when another issue links this issue
type WasLinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    linkedBy: Issue
}

#when another issue unlinks this issue
type WasUnlinkedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    unlinkedBy: Issue
}

type LabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    label: Label!
}

input AddLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type AddLabelPayload {
    clientMutationID: String
    label: Label
    labelEdge: LabelEdge
    timelineEdge: IssueTimelineItemEdge
}

type UnlabelledEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLabel: Label!
}

input RemoveLabelInput {
    clientMutationID: String
    issue: ID!
    label: ID!
}

type RemoveLabelPayload {
    clientMutationID: String
    label: Label
    timelineEdge: IssueTimelineItemEdge
}

type PinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input PinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type PinIssuePayload {
    clientMutationID: String
    pinnedIssue: Issue
    component: Component
    timelineEdge: IssueTimelineItemEdge
}

type UnpinnedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

input UnpinIssueInput {
    clientMutationID: String
    issue: ID!
    component: ID!
}

type UnpinIssuePayload {
    clientMutationID: String
    unpinnedIssue: Issue
    component: Component
    timelineEdge: IssueTimelineItemEdge
}

type RenamedTitleEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldTitle: String!
    newTitle: String!
}

input RenameTitleInput {
    clientMutationID: String
    issue: ID!
    newTitle: String!
}

type RenameTitlePayload {
    clientMutationID: String
    issue: Issue
    timelineEdge: IssueTimelineItemEdge
}

type CategoryChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldType: IssueCategory!
    newType: IssueCategory!
}

type AssignedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    assignee: User!
}

type UnassignedEvet implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedAssignee: User!
}

type ClosedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type ReopenedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}

type PriorityChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldPriority: Priority
    newPriority: Priority
}

type StartDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldStartDate: Date
    newStartDate: Date
}

type DueDateChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldDueDate: Date
    newDueDate: Date
}

type EstimatedTimeChangedEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    oldEstimatedTime: TimeSpan
    newEstimatedTime: TimeSpan
}

type AddedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    location: IssueLocation!
}

type RemovedLocationEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    removedLocation: IssueLocation!
}

type MarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
    originalIssue: Issue
}

type UnmarkedAsDuplicateEvent implements IssueTimelineItem & Node {
    id: ID!
    issue: Issue!
    createdBy: User
    createdAt: Date!
}



type ReactionGroup {
    users: [User]
    reaction: String!
}

type ReactionGroupPage {
    nodes: [ReactionGroup]
    edges: [ReactionGroupEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ReactionGroupEdge {
    node: ReactionGroup
    cursor: String
}

"""
A filter for reaction groups (a reaction together with the users who reacted)
"""
input ReactionGroupFilter {
    """
    The reactions name must match any one or more of the given strings
    """
    reaction: [String!]
    """
    A list of Users who reacted. Any reaction group which contains at least one of the given users will match the filter
    """
    users: [ID!]
}

type Label implements Node {
    id: ID!
    name: String!
    description: String
    colour: Colour
}

type LabelPage {
    nodes: [Label]
    edges: [LabelEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type LabelEdge {
    node: Label
    cursor: String
}

"""
A Filter data input for labels
"""
input LabelFilter {
    """
    A lists of names. The label needs to match any one or more of these.
    """
    name: [String!]
    """
    The __RegEx__ the description of the label needs to match
    """
    description: String

    """
    A list of label colours. Any one or more of the given colours need to match the labels colour.
    """
    colour: [Color!]
}

#-------------------------------------Scalars and enums------------------------------------

"""
The Priority which an issue has - how urgent it needs to be resolved
"""
enum Priority {

    """
    The issue has a low priority but higher than issues without priority
    """
    LOW,
    """
    The issue has a priority higher than low bot is not absolutely urgent
    """
    MEDIUM,
    """
    Issues with this priority are __very__ urgent and need to be resolved quickly
    """
    HIGH
}

"""
The category of an issue. The issue will be displayed accordingly in the ccims
"""
enum IssueCategory {

    """
    If an issue is classified _bug_ it describes an error, flaw or fault in one ore multiple component(s) or interface(s)
    """
    BUG,

    """
    If an issue is defined a _feature request_, it describes a functionality that is to be implemented at some point
    """
    FEATURE_REQUEST,

    """
    The category for issues, that either weren't yet assigned to a category or that don't fit into one of the other categories
    """
    UNCLASSIFIED
}

"""
The type of a timeline item/event so it can be filtered for <sup>(because GraphQL doesn't allow to filter for a type)</sup>
"""
enum IssueTimelineItemType {
    """
    A still visible comment on an issue (not including the actual issue text)
    """
    ISSUE_COMMENT,

    """
    A comment that has been deleted by a user. This will contain no text etc., but a message should be shown in place of the comment stating that this is a deleted comment
    """
    DELETED_ISSUE_COMMENT,

    """
    An event when this issue was referenced by an element in an IMS that is not an issue (e.g. in a commit message, pull request etc.)
    """
    REFERENCED_BY_OTHER_EVENT,

    """
    An event when this issue was referenced by an other issue in an IMS or the ccims itself
    """
    REFERENCED_BY_ISSUE_EVENT,

    """
    A link from this issue to another issue was created
    """
    LINK_EVENT,

    """
    A link from this issue to another issue was removed
    """
    UNLINK_EVENT,

    """
    An event if this issue was linked to in another issue
    """
    WAS_LINKED_EVENT,

    """
    An event if the link from another issue to this one was removed
    """
    WAS_UNLINKED_EVENT,


    """
    A label was added to this issue
    """
    LABELLED_EVENT,

    """
    A label was removed from tis issue
    """
    UNLABELLED_EVENT,

    """
    This issue was pinned as important issue in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    PINNED_EVENT,

    """
    This issue was unpinned in the ccims.
    __This event won't be synced along all subscribed issue management systems__
    """
    UNPINNED_EVENT,

    """
    Occurs if the title of the issue has been changed
    """
    RENAMED_TITLE_EVENT,

    """
    An event if the category (see `enum IssueCategory`) of the issue has been changed
    """
    CATEGORY_CHANGED_EVENT,

    """
    If a user has been assigned as responsible person for this issue
    """
    ASSIGNED_EVENT,

    """
    If a user has been unassigned from this issue and is no longer responsible
    """
    UNASSIGNED_EVENT,

    """
    Happens if the issue has been closed by anybody
    """
    CLOSED_EVENT,

    """
    Happens if the issue has been reopened after being closed by anybody.

    _This event doesn't occur on the first opening of the issue_
    """
    REOPENED_EVENT,

    """
    If the issue priority was changed (see `enum Priority`)
    """
    PRIORITY_CHANGED_EVENT,

    """
    An event if the date the issue gets relevant/starts has changed
    """
    START_DATE_CHANGED_EVENT,

    """
    An event if the date the issue is due on/must be finished by was changed
    """
    DUE_DATE_CHANGED_EVENT,

    """
    The estimated time required to resolve this issue was updated
    """
    ESTIMATED_TIME_CHANGED_EVENT,

    """
    Event if the cross component issue was added to another location (another component/another)
    """
    ADDED_LOCATION_EVENT,

    """
    Event if the cross component issue was removed from a location (another component/another)
    """
    REMOVED_LOCATION_EVENT,

    """
    Occurs if this issue was marked as duplicate of some other issue which is known to the ccims.
    
    (if the issue in unknown to the ccims at time of marking it as a duplicate; it's not guaranteed, that the mark will be synced)
    """
    MARKED_AS_DUPLICATE_EVENT,

    """
    An event if the issue is no longer a duplicate of another issue
    """
    UNMARKED_AS_DUPLICATE_EVENT,
}

"""
The `Date` scalar is a sting containing a date in a format compatible with _ISO-8601_

Example: `"2011-10-10T14:48:00"`
"""
scalar Date

"""
A integer number representing the length of the time span in milliseconds

Example: `60000` (equivalent to a time span of one minute)
"""
scalar TimeSpan

"""
A scalar type representing a colour in RGB colour space.
The scalar must be a string in CSS Colour Hex format: 
`#rrggbb` where `rr`, `gg`, `bb` are the hex values between _0_ and _ff_

Example: `#ffff00` (would be a _beautiful_ yellow)
"""
scalar Colour

#--------------------------------Union types-------------------------------------------------
union IssueLocation = Component | ComponentInterface

type IssueLocationPage {
    nodes: [IssueLocation]
    edges: [IssueLocationEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type IssueLocationEdge {
    node: IssueLocation
    cursor: String
}

input IssueLocationFilter {
    name: String
}